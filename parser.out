Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> P
Rule 1     P -> program id VARIABLES SUBROUTINES STATEMENTS end program
Rule 2     VARIABLES -> TYPE id ARRAY semicolon VARIABLES
Rule 3     VARIABLES -> <empty>
Rule 4     TYPE -> integer
Rule 5     TYPE -> real
Rule 6     ARRAY -> openBracket int closeBracket openBracket int closeBracket
Rule 7     ARRAY -> openBracket int closeBracket
Rule 8     ARRAY -> <empty>
Rule 9     SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES
Rule 10    SUBROUTINES -> <empty>
Rule 11    STATEMENTS -> if LOGEXP then STATEMENTS ELIF ELSE end if
Rule 12    STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
Rule 13    STATEMENTS -> VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
Rule 14    STATEMENTS -> call id semicolon STATEMENTS
Rule 15    STATEMENTS -> read READVAR semicolon STATEMENTS
Rule 16    STATEMENTS -> write WRITEVAR semicolon STATEMENTS
Rule 17    STATEMENTS -> exit STATEMENTS
Rule 18    STATEMENTS -> <empty>
Rule 19    ELIF -> elif LOGEXP then STATEMENTS ELIF
Rule 20    ELIF -> <empty>
Rule 21    ELSE -> else STATEMENTS
Rule 22    ELSE -> <empty>
Rule 23    LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP
Rule 24    LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP
Rule 25    ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
Rule 26    ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP
Rule 27    COMPARISON -> openParentheses LOGEXP closeParentheses
Rule 28    COMPARISON -> VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
Rule 29    COMPARISON -> not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
Rule 30    COMP -> doubleEqual
Rule 31    COMP -> notEqual
Rule 32    COMP -> biggerOrEqualThan
Rule 33    COMP -> smallerOrEqualThan
Rule 34    COMP -> biggerThan
Rule 35    COMP -> smallerThan
Rule 36    READVAR -> VAR READV
Rule 37    READV -> coma VAR READV
Rule 38    READV -> <empty>
Rule 39    WRITEVAR -> VAR WRITEV
Rule 40    WRITEVAR -> string WRITEV
Rule 41    WRITEV -> coma VAR WRITEV
Rule 42    WRITEV -> coma string WRITEV
Rule 43    WRITEV -> <empty>
Rule 44    ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP
Rule 45    ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
Rule 46    ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
Rule 47    MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
Rule 48    MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
Rule 49    MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
Rule 50    VALUE -> VAL
Rule 51    VALUE -> openParentheses ARITEXP closeParentheses
Rule 52    VAL -> VAR ACTION_VAR_VAL
Rule 53    VAL -> int ACTION_INT_VAL
Rule 54    VAL -> real ACTION_REAL_VAL
Rule 55    VAR -> id ARRAY
Rule 56    ACTION_VAR_VAL -> <empty>
Rule 57    ACTION_INT_VAL -> <empty>
Rule 58    ACTION_REAL_VAL -> <empty>
Rule 59    ACTION_PLUSSIGN_ARITEXP -> <empty>
Rule 60    ACTION_MINUSSIGN_ARITEXP -> <empty>
Rule 61    ACTION_GENERATE_QUADRUPLET_SET -> <empty>
Rule 62    ACTION_MULTSIGN_MULDIV -> <empty>
Rule 63    ACTION_DIVSIGN_MULDIV -> <empty>
Rule 64    ACTION_GENERATE_QUADRUPLET_ARITEXP -> <empty>
Rule 65    ACTION_GENERATE_QUADRUPLET_MULDIV -> <empty>
Rule 66    ACTION_OR_LOGEXP -> <empty>
Rule 67    ACTION_AND_ANDEXP -> <empty>
Rule 68    ACTION_CREATE_QUADRUPLE_LOGEXP -> <empty>
Rule 69    ACTION_GENERATE_QUADRUPLE_ANDEXP -> <empty>
Rule 70    ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON -> <empty>
Rule 71    ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON -> <empty>

Terminals, with rules where they appear

and                  : 25
biggerOrEqualThan    : 32
biggerThan           : 34
call                 : 14
closeBracket         : 6 6 7
closeParentheses     : 27 51
coma                 : 37 41 42
divSign              : 49
do                   : 12 12
doubleEqual          : 30
elif                 : 19
else                 : 21
end                  : 1 9 11 12
equal                : 12 13
error                : 
exit                 : 17
id                   : 1 2 9 12 14 55
if                   : 11 11
int                  : 6 6 7 53
integer              : 4
minusSign            : 46
multSign             : 48
not                  : 29
notEqual             : 31
openBracket          : 6 6 7
openParentheses      : 27 51
or                   : 23
plusSign             : 45
program              : 1 1
read                 : 15
real                 : 5 54
semicolon            : 2 12 14 15 16
smallerOrEqualThan   : 33
smallerThan          : 35
string               : 40 42
subroutine           : 9 9
then                 : 11 19
write                : 16

Nonterminals, with rules where they appear

ACTION_AND_ANDEXP    : 25
ACTION_CREATE_QUADRUPLE_LOGEXP : 23 24
ACTION_DIVSIGN_MULDIV : 49
ACTION_GENERATE_QUADRUPLET_ARITEXP : 44 45 46
ACTION_GENERATE_QUADRUPLET_MULDIV : 47 48 49
ACTION_GENERATE_QUADRUPLET_SET : 13
ACTION_GENERATE_QUADRUPLE_ANDEXP : 25 26
ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON : 28
ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON : 29
ACTION_INT_VAL       : 53
ACTION_MINUSSIGN_ARITEXP : 46
ACTION_MULTSIGN_MULDIV : 48
ACTION_OR_LOGEXP     : 23
ACTION_PLUSSIGN_ARITEXP : 45
ACTION_REAL_VAL      : 54
ACTION_VAR_VAL       : 52
ANDEXP               : 23 24 25
ARITEXP              : 12 13 45 46 51
ARRAY                : 2 55
COMP                 : 28
COMPARISON           : 25 26
ELIF                 : 11 19
ELSE                 : 11
LOGEXP               : 11 19 23 27 29
MULDIV               : 44 45 46 48 49
P                    : 0
READV                : 36 37
READVAR              : 15
STATEMENTS           : 1 9 11 12 12 13 14 15 16 17 19 21
SUBROUTINES          : 1 9
TYPE                 : 2
VAL                  : 50
VALUE                : 28 28 47 48 49
VAR                  : 13 36 37 39 41 52
VARIABLES            : 1 2
WRITEV               : 39 40 41 42
WRITEVAR             : 16

Parsing method: LALR

state 0

    (0) S' -> . P
    (1) P -> . program id VARIABLES SUBROUTINES STATEMENTS end program

    program         shift and go to state 2

    P                              shift and go to state 1

state 1

    (0) S' -> P .



state 2

    (1) P -> program . id VARIABLES SUBROUTINES STATEMENTS end program

    id              shift and go to state 3


state 3

    (1) P -> program id . VARIABLES SUBROUTINES STATEMENTS end program
    (2) VARIABLES -> . TYPE id ARRAY semicolon VARIABLES
    (3) VARIABLES -> .
    (4) TYPE -> . integer
    (5) TYPE -> . real

    subroutine      reduce using rule 3 (VARIABLES -> .)
    if              reduce using rule 3 (VARIABLES -> .)
    do              reduce using rule 3 (VARIABLES -> .)
    call            reduce using rule 3 (VARIABLES -> .)
    read            reduce using rule 3 (VARIABLES -> .)
    write           reduce using rule 3 (VARIABLES -> .)
    exit            reduce using rule 3 (VARIABLES -> .)
    id              reduce using rule 3 (VARIABLES -> .)
    end             reduce using rule 3 (VARIABLES -> .)
    integer         shift and go to state 6
    real            shift and go to state 7

    VARIABLES                      shift and go to state 4
    TYPE                           shift and go to state 5

state 4

    (1) P -> program id VARIABLES . SUBROUTINES STATEMENTS end program
    (9) SUBROUTINES -> . subroutine id STATEMENTS end subroutine SUBROUTINES
    (10) SUBROUTINES -> .

    subroutine      shift and go to state 9
    if              reduce using rule 10 (SUBROUTINES -> .)
    do              reduce using rule 10 (SUBROUTINES -> .)
    call            reduce using rule 10 (SUBROUTINES -> .)
    read            reduce using rule 10 (SUBROUTINES -> .)
    write           reduce using rule 10 (SUBROUTINES -> .)
    exit            reduce using rule 10 (SUBROUTINES -> .)
    id              reduce using rule 10 (SUBROUTINES -> .)
    end             reduce using rule 10 (SUBROUTINES -> .)

    SUBROUTINES                    shift and go to state 8

state 5

    (2) VARIABLES -> TYPE . id ARRAY semicolon VARIABLES

    id              shift and go to state 10


state 6

    (4) TYPE -> integer .

    id              reduce using rule 4 (TYPE -> integer .)


state 7

    (5) TYPE -> real .

    id              reduce using rule 5 (TYPE -> real .)


state 8

    (1) P -> program id VARIABLES SUBROUTINES . STATEMENTS end program
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 12
    VAR                            shift and go to state 15

state 9

    (9) SUBROUTINES -> subroutine . id STATEMENTS end subroutine SUBROUTINES

    id              shift and go to state 20


state 10

    (2) VARIABLES -> TYPE id . ARRAY semicolon VARIABLES
    (6) ARRAY -> . openBracket int closeBracket openBracket int closeBracket
    (7) ARRAY -> . openBracket int closeBracket
    (8) ARRAY -> .

    openBracket     shift and go to state 22
    semicolon       reduce using rule 8 (ARRAY -> .)

    ARRAY                          shift and go to state 21

state 11

    (55) VAR -> id . ARRAY
    (6) ARRAY -> . openBracket int closeBracket openBracket int closeBracket
    (7) ARRAY -> . openBracket int closeBracket
    (8) ARRAY -> .

    openBracket     shift and go to state 22
    equal           reduce using rule 8 (ARRAY -> .)
    doubleEqual     reduce using rule 8 (ARRAY -> .)
    notEqual        reduce using rule 8 (ARRAY -> .)
    biggerOrEqualThan reduce using rule 8 (ARRAY -> .)
    smallerOrEqualThan reduce using rule 8 (ARRAY -> .)
    biggerThan      reduce using rule 8 (ARRAY -> .)
    smallerThan     reduce using rule 8 (ARRAY -> .)
    coma            reduce using rule 8 (ARRAY -> .)
    semicolon       reduce using rule 8 (ARRAY -> .)
    multSign        reduce using rule 8 (ARRAY -> .)
    divSign         reduce using rule 8 (ARRAY -> .)
    plusSign        reduce using rule 8 (ARRAY -> .)
    minusSign       reduce using rule 8 (ARRAY -> .)
    closeParentheses reduce using rule 8 (ARRAY -> .)
    if              reduce using rule 8 (ARRAY -> .)
    do              reduce using rule 8 (ARRAY -> .)
    call            reduce using rule 8 (ARRAY -> .)
    read            reduce using rule 8 (ARRAY -> .)
    write           reduce using rule 8 (ARRAY -> .)
    exit            reduce using rule 8 (ARRAY -> .)
    id              reduce using rule 8 (ARRAY -> .)
    end             reduce using rule 8 (ARRAY -> .)
    elif            reduce using rule 8 (ARRAY -> .)
    else            reduce using rule 8 (ARRAY -> .)
    and             reduce using rule 8 (ARRAY -> .)
    or              reduce using rule 8 (ARRAY -> .)
    then            reduce using rule 8 (ARRAY -> .)

    ARRAY                          shift and go to state 23

state 12

    (1) P -> program id VARIABLES SUBROUTINES STATEMENTS . end program

    end             shift and go to state 24


state 13

    (11) STATEMENTS -> if . LOGEXP then STATEMENTS ELIF ELSE end if
    (23) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP
    (24) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP
    (25) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP
    (27) COMPARISON -> . openParentheses LOGEXP closeParentheses
    (28) COMPARISON -> . VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (29) COMPARISON -> . not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 28
    not             shift and go to state 30
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    LOGEXP                         shift and go to state 25
    ANDEXP                         shift and go to state 26
    COMPARISON                     shift and go to state 27
    VALUE                          shift and go to state 29
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 14

    (12) STATEMENTS -> do . id equal ARITEXP semicolon STATEMENTS end do STATEMENTS

    id              shift and go to state 35


state 15

    (13) STATEMENTS -> VAR . equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS

    equal           shift and go to state 36


state 16

    (14) STATEMENTS -> call . id semicolon STATEMENTS

    id              shift and go to state 37


state 17

    (15) STATEMENTS -> read . READVAR semicolon STATEMENTS
    (36) READVAR -> . VAR READV
    (55) VAR -> . id ARRAY

    id              shift and go to state 11

    READVAR                        shift and go to state 38
    VAR                            shift and go to state 39

state 18

    (16) STATEMENTS -> write . WRITEVAR semicolon STATEMENTS
    (39) WRITEVAR -> . VAR WRITEV
    (40) WRITEVAR -> . string WRITEV
    (55) VAR -> . id ARRAY

    string          shift and go to state 42
    id              shift and go to state 11

    WRITEVAR                       shift and go to state 40
    VAR                            shift and go to state 41

state 19

    (17) STATEMENTS -> exit . STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 43
    VAR                            shift and go to state 15

state 20

    (9) SUBROUTINES -> subroutine id . STATEMENTS end subroutine SUBROUTINES
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 44
    VAR                            shift and go to state 15

state 21

    (2) VARIABLES -> TYPE id ARRAY . semicolon VARIABLES

    semicolon       shift and go to state 45


state 22

    (6) ARRAY -> openBracket . int closeBracket openBracket int closeBracket
    (7) ARRAY -> openBracket . int closeBracket

    int             shift and go to state 46


state 23

    (55) VAR -> id ARRAY .

    equal           reduce using rule 55 (VAR -> id ARRAY .)
    doubleEqual     reduce using rule 55 (VAR -> id ARRAY .)
    notEqual        reduce using rule 55 (VAR -> id ARRAY .)
    biggerOrEqualThan reduce using rule 55 (VAR -> id ARRAY .)
    smallerOrEqualThan reduce using rule 55 (VAR -> id ARRAY .)
    biggerThan      reduce using rule 55 (VAR -> id ARRAY .)
    smallerThan     reduce using rule 55 (VAR -> id ARRAY .)
    coma            reduce using rule 55 (VAR -> id ARRAY .)
    semicolon       reduce using rule 55 (VAR -> id ARRAY .)
    multSign        reduce using rule 55 (VAR -> id ARRAY .)
    divSign         reduce using rule 55 (VAR -> id ARRAY .)
    plusSign        reduce using rule 55 (VAR -> id ARRAY .)
    minusSign       reduce using rule 55 (VAR -> id ARRAY .)
    closeParentheses reduce using rule 55 (VAR -> id ARRAY .)
    if              reduce using rule 55 (VAR -> id ARRAY .)
    do              reduce using rule 55 (VAR -> id ARRAY .)
    call            reduce using rule 55 (VAR -> id ARRAY .)
    read            reduce using rule 55 (VAR -> id ARRAY .)
    write           reduce using rule 55 (VAR -> id ARRAY .)
    exit            reduce using rule 55 (VAR -> id ARRAY .)
    id              reduce using rule 55 (VAR -> id ARRAY .)
    end             reduce using rule 55 (VAR -> id ARRAY .)
    elif            reduce using rule 55 (VAR -> id ARRAY .)
    else            reduce using rule 55 (VAR -> id ARRAY .)
    and             reduce using rule 55 (VAR -> id ARRAY .)
    or              reduce using rule 55 (VAR -> id ARRAY .)
    then            reduce using rule 55 (VAR -> id ARRAY .)


state 24

    (1) P -> program id VARIABLES SUBROUTINES STATEMENTS end . program

    program         shift and go to state 47


state 25

    (11) STATEMENTS -> if LOGEXP . then STATEMENTS ELIF ELSE end if

    then            shift and go to state 48


state 26

    (23) LOGEXP -> ANDEXP . ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP
    (24) LOGEXP -> ANDEXP . ACTION_CREATE_QUADRUPLE_LOGEXP
    (68) ACTION_CREATE_QUADRUPLE_LOGEXP -> .

    or              reduce using rule 68 (ACTION_CREATE_QUADRUPLE_LOGEXP -> .)
    then            reduce using rule 68 (ACTION_CREATE_QUADRUPLE_LOGEXP -> .)
    closeParentheses reduce using rule 68 (ACTION_CREATE_QUADRUPLE_LOGEXP -> .)
    and             reduce using rule 68 (ACTION_CREATE_QUADRUPLE_LOGEXP -> .)

    ACTION_CREATE_QUADRUPLE_LOGEXP shift and go to state 49

state 27

    (25) ANDEXP -> COMPARISON . ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> COMPARISON . ACTION_GENERATE_QUADRUPLE_ANDEXP
    (69) ACTION_GENERATE_QUADRUPLE_ANDEXP -> .

    and             reduce using rule 69 (ACTION_GENERATE_QUADRUPLE_ANDEXP -> .)
    or              reduce using rule 69 (ACTION_GENERATE_QUADRUPLE_ANDEXP -> .)
    then            reduce using rule 69 (ACTION_GENERATE_QUADRUPLE_ANDEXP -> .)
    closeParentheses reduce using rule 69 (ACTION_GENERATE_QUADRUPLE_ANDEXP -> .)

    ACTION_GENERATE_QUADRUPLE_ANDEXP shift and go to state 50

state 28

    (27) COMPARISON -> openParentheses . LOGEXP closeParentheses
    (51) VALUE -> openParentheses . ARITEXP closeParentheses
    (23) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP
    (24) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP
    (44) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP
    (45) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
    (25) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (27) COMPARISON -> . openParentheses LOGEXP closeParentheses
    (28) COMPARISON -> . VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (29) COMPARISON -> . not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 28
    not             shift and go to state 30
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    LOGEXP                         shift and go to state 51
    ARITEXP                        shift and go to state 52
    ANDEXP                         shift and go to state 26
    MULDIV                         shift and go to state 53
    COMPARISON                     shift and go to state 27
    VALUE                          shift and go to state 54
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 29

    (28) COMPARISON -> VALUE . COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (30) COMP -> . doubleEqual
    (31) COMP -> . notEqual
    (32) COMP -> . biggerOrEqualThan
    (33) COMP -> . smallerOrEqualThan
    (34) COMP -> . biggerThan
    (35) COMP -> . smallerThan

    doubleEqual     shift and go to state 56
    notEqual        shift and go to state 57
    biggerOrEqualThan shift and go to state 58
    smallerOrEqualThan shift and go to state 59
    biggerThan      shift and go to state 60
    smallerThan     shift and go to state 61

    COMP                           shift and go to state 55

state 30

    (29) COMPARISON -> not . LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (23) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP
    (24) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP
    (25) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP
    (27) COMPARISON -> . openParentheses LOGEXP closeParentheses
    (28) COMPARISON -> . VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (29) COMPARISON -> . not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 28
    not             shift and go to state 30
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    LOGEXP                         shift and go to state 62
    ANDEXP                         shift and go to state 26
    COMPARISON                     shift and go to state 27
    VALUE                          shift and go to state 29
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 31

    (50) VALUE -> VAL .

    doubleEqual     reduce using rule 50 (VALUE -> VAL .)
    notEqual        reduce using rule 50 (VALUE -> VAL .)
    biggerOrEqualThan reduce using rule 50 (VALUE -> VAL .)
    smallerOrEqualThan reduce using rule 50 (VALUE -> VAL .)
    biggerThan      reduce using rule 50 (VALUE -> VAL .)
    smallerThan     reduce using rule 50 (VALUE -> VAL .)
    multSign        reduce using rule 50 (VALUE -> VAL .)
    divSign         reduce using rule 50 (VALUE -> VAL .)
    plusSign        reduce using rule 50 (VALUE -> VAL .)
    minusSign       reduce using rule 50 (VALUE -> VAL .)
    closeParentheses reduce using rule 50 (VALUE -> VAL .)
    if              reduce using rule 50 (VALUE -> VAL .)
    do              reduce using rule 50 (VALUE -> VAL .)
    call            reduce using rule 50 (VALUE -> VAL .)
    read            reduce using rule 50 (VALUE -> VAL .)
    write           reduce using rule 50 (VALUE -> VAL .)
    exit            reduce using rule 50 (VALUE -> VAL .)
    id              reduce using rule 50 (VALUE -> VAL .)
    end             reduce using rule 50 (VALUE -> VAL .)
    elif            reduce using rule 50 (VALUE -> VAL .)
    else            reduce using rule 50 (VALUE -> VAL .)
    and             reduce using rule 50 (VALUE -> VAL .)
    or              reduce using rule 50 (VALUE -> VAL .)
    then            reduce using rule 50 (VALUE -> VAL .)
    semicolon       reduce using rule 50 (VALUE -> VAL .)


state 32

    (52) VAL -> VAR . ACTION_VAR_VAL
    (56) ACTION_VAR_VAL -> .

    doubleEqual     reduce using rule 56 (ACTION_VAR_VAL -> .)
    notEqual        reduce using rule 56 (ACTION_VAR_VAL -> .)
    biggerOrEqualThan reduce using rule 56 (ACTION_VAR_VAL -> .)
    smallerOrEqualThan reduce using rule 56 (ACTION_VAR_VAL -> .)
    biggerThan      reduce using rule 56 (ACTION_VAR_VAL -> .)
    smallerThan     reduce using rule 56 (ACTION_VAR_VAL -> .)
    multSign        reduce using rule 56 (ACTION_VAR_VAL -> .)
    divSign         reduce using rule 56 (ACTION_VAR_VAL -> .)
    plusSign        reduce using rule 56 (ACTION_VAR_VAL -> .)
    minusSign       reduce using rule 56 (ACTION_VAR_VAL -> .)
    closeParentheses reduce using rule 56 (ACTION_VAR_VAL -> .)
    if              reduce using rule 56 (ACTION_VAR_VAL -> .)
    do              reduce using rule 56 (ACTION_VAR_VAL -> .)
    call            reduce using rule 56 (ACTION_VAR_VAL -> .)
    read            reduce using rule 56 (ACTION_VAR_VAL -> .)
    write           reduce using rule 56 (ACTION_VAR_VAL -> .)
    exit            reduce using rule 56 (ACTION_VAR_VAL -> .)
    id              reduce using rule 56 (ACTION_VAR_VAL -> .)
    end             reduce using rule 56 (ACTION_VAR_VAL -> .)
    elif            reduce using rule 56 (ACTION_VAR_VAL -> .)
    else            reduce using rule 56 (ACTION_VAR_VAL -> .)
    and             reduce using rule 56 (ACTION_VAR_VAL -> .)
    or              reduce using rule 56 (ACTION_VAR_VAL -> .)
    then            reduce using rule 56 (ACTION_VAR_VAL -> .)
    semicolon       reduce using rule 56 (ACTION_VAR_VAL -> .)

    ACTION_VAR_VAL                 shift and go to state 63

state 33

    (53) VAL -> int . ACTION_INT_VAL
    (57) ACTION_INT_VAL -> .

    doubleEqual     reduce using rule 57 (ACTION_INT_VAL -> .)
    notEqual        reduce using rule 57 (ACTION_INT_VAL -> .)
    biggerOrEqualThan reduce using rule 57 (ACTION_INT_VAL -> .)
    smallerOrEqualThan reduce using rule 57 (ACTION_INT_VAL -> .)
    biggerThan      reduce using rule 57 (ACTION_INT_VAL -> .)
    smallerThan     reduce using rule 57 (ACTION_INT_VAL -> .)
    multSign        reduce using rule 57 (ACTION_INT_VAL -> .)
    divSign         reduce using rule 57 (ACTION_INT_VAL -> .)
    plusSign        reduce using rule 57 (ACTION_INT_VAL -> .)
    minusSign       reduce using rule 57 (ACTION_INT_VAL -> .)
    closeParentheses reduce using rule 57 (ACTION_INT_VAL -> .)
    if              reduce using rule 57 (ACTION_INT_VAL -> .)
    do              reduce using rule 57 (ACTION_INT_VAL -> .)
    call            reduce using rule 57 (ACTION_INT_VAL -> .)
    read            reduce using rule 57 (ACTION_INT_VAL -> .)
    write           reduce using rule 57 (ACTION_INT_VAL -> .)
    exit            reduce using rule 57 (ACTION_INT_VAL -> .)
    id              reduce using rule 57 (ACTION_INT_VAL -> .)
    end             reduce using rule 57 (ACTION_INT_VAL -> .)
    elif            reduce using rule 57 (ACTION_INT_VAL -> .)
    else            reduce using rule 57 (ACTION_INT_VAL -> .)
    and             reduce using rule 57 (ACTION_INT_VAL -> .)
    or              reduce using rule 57 (ACTION_INT_VAL -> .)
    then            reduce using rule 57 (ACTION_INT_VAL -> .)
    semicolon       reduce using rule 57 (ACTION_INT_VAL -> .)

    ACTION_INT_VAL                 shift and go to state 64

state 34

    (54) VAL -> real . ACTION_REAL_VAL
    (58) ACTION_REAL_VAL -> .

    doubleEqual     reduce using rule 58 (ACTION_REAL_VAL -> .)
    notEqual        reduce using rule 58 (ACTION_REAL_VAL -> .)
    biggerOrEqualThan reduce using rule 58 (ACTION_REAL_VAL -> .)
    smallerOrEqualThan reduce using rule 58 (ACTION_REAL_VAL -> .)
    biggerThan      reduce using rule 58 (ACTION_REAL_VAL -> .)
    smallerThan     reduce using rule 58 (ACTION_REAL_VAL -> .)
    multSign        reduce using rule 58 (ACTION_REAL_VAL -> .)
    divSign         reduce using rule 58 (ACTION_REAL_VAL -> .)
    plusSign        reduce using rule 58 (ACTION_REAL_VAL -> .)
    minusSign       reduce using rule 58 (ACTION_REAL_VAL -> .)
    closeParentheses reduce using rule 58 (ACTION_REAL_VAL -> .)
    if              reduce using rule 58 (ACTION_REAL_VAL -> .)
    do              reduce using rule 58 (ACTION_REAL_VAL -> .)
    call            reduce using rule 58 (ACTION_REAL_VAL -> .)
    read            reduce using rule 58 (ACTION_REAL_VAL -> .)
    write           reduce using rule 58 (ACTION_REAL_VAL -> .)
    exit            reduce using rule 58 (ACTION_REAL_VAL -> .)
    id              reduce using rule 58 (ACTION_REAL_VAL -> .)
    end             reduce using rule 58 (ACTION_REAL_VAL -> .)
    elif            reduce using rule 58 (ACTION_REAL_VAL -> .)
    else            reduce using rule 58 (ACTION_REAL_VAL -> .)
    and             reduce using rule 58 (ACTION_REAL_VAL -> .)
    or              reduce using rule 58 (ACTION_REAL_VAL -> .)
    then            reduce using rule 58 (ACTION_REAL_VAL -> .)
    semicolon       reduce using rule 58 (ACTION_REAL_VAL -> .)

    ACTION_REAL_VAL                shift and go to state 65

state 35

    (12) STATEMENTS -> do id . equal ARITEXP semicolon STATEMENTS end do STATEMENTS

    equal           shift and go to state 66


state 36

    (13) STATEMENTS -> VAR equal . ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (44) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP
    (45) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    VAR                            shift and go to state 32
    ARITEXP                        shift and go to state 67
    MULDIV                         shift and go to state 53
    VALUE                          shift and go to state 68
    VAL                            shift and go to state 31

state 37

    (14) STATEMENTS -> call id . semicolon STATEMENTS

    semicolon       shift and go to state 70


state 38

    (15) STATEMENTS -> read READVAR . semicolon STATEMENTS

    semicolon       shift and go to state 71


state 39

    (36) READVAR -> VAR . READV
    (37) READV -> . coma VAR READV
    (38) READV -> .

    coma            shift and go to state 73
    semicolon       reduce using rule 38 (READV -> .)

    READV                          shift and go to state 72

state 40

    (16) STATEMENTS -> write WRITEVAR . semicolon STATEMENTS

    semicolon       shift and go to state 74


state 41

    (39) WRITEVAR -> VAR . WRITEV
    (41) WRITEV -> . coma VAR WRITEV
    (42) WRITEV -> . coma string WRITEV
    (43) WRITEV -> .

    coma            shift and go to state 76
    semicolon       reduce using rule 43 (WRITEV -> .)

    WRITEV                         shift and go to state 75

state 42

    (40) WRITEVAR -> string . WRITEV
    (41) WRITEV -> . coma VAR WRITEV
    (42) WRITEV -> . coma string WRITEV
    (43) WRITEV -> .

    coma            shift and go to state 76
    semicolon       reduce using rule 43 (WRITEV -> .)

    WRITEV                         shift and go to state 77

state 43

    (17) STATEMENTS -> exit STATEMENTS .

    end             reduce using rule 17 (STATEMENTS -> exit STATEMENTS .)
    elif            reduce using rule 17 (STATEMENTS -> exit STATEMENTS .)
    else            reduce using rule 17 (STATEMENTS -> exit STATEMENTS .)


state 44

    (9) SUBROUTINES -> subroutine id STATEMENTS . end subroutine SUBROUTINES

    end             shift and go to state 78


state 45

    (2) VARIABLES -> TYPE id ARRAY semicolon . VARIABLES
    (2) VARIABLES -> . TYPE id ARRAY semicolon VARIABLES
    (3) VARIABLES -> .
    (4) TYPE -> . integer
    (5) TYPE -> . real

    subroutine      reduce using rule 3 (VARIABLES -> .)
    if              reduce using rule 3 (VARIABLES -> .)
    do              reduce using rule 3 (VARIABLES -> .)
    call            reduce using rule 3 (VARIABLES -> .)
    read            reduce using rule 3 (VARIABLES -> .)
    write           reduce using rule 3 (VARIABLES -> .)
    exit            reduce using rule 3 (VARIABLES -> .)
    id              reduce using rule 3 (VARIABLES -> .)
    end             reduce using rule 3 (VARIABLES -> .)
    integer         shift and go to state 6
    real            shift and go to state 7

    TYPE                           shift and go to state 5
    VARIABLES                      shift and go to state 79

state 46

    (6) ARRAY -> openBracket int . closeBracket openBracket int closeBracket
    (7) ARRAY -> openBracket int . closeBracket

    closeBracket    shift and go to state 80


state 47

    (1) P -> program id VARIABLES SUBROUTINES STATEMENTS end program .

    $end            reduce using rule 1 (P -> program id VARIABLES SUBROUTINES STATEMENTS end program .)


state 48

    (11) STATEMENTS -> if LOGEXP then . STATEMENTS ELIF ELSE end if
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    end             reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 81
    VAR                            shift and go to state 15

state 49

    (23) LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP . or ACTION_OR_LOGEXP LOGEXP
    (24) LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP .

  ! shift/reduce conflict for or resolved as shift
    or              shift and go to state 82
    then            reduce using rule 24 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP .)
    closeParentheses reduce using rule 24 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP .)
    and             reduce using rule 24 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP .)

  ! or              [ reduce using rule 24 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP .) ]


state 50

    (25) ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP . and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP .

  ! shift/reduce conflict for and resolved as shift
    and             shift and go to state 83
    or              reduce using rule 26 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP .)
    then            reduce using rule 26 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP .)
    closeParentheses reduce using rule 26 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP .)

  ! and             [ reduce using rule 26 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP .) ]


state 51

    (27) COMPARISON -> openParentheses LOGEXP . closeParentheses

    closeParentheses shift and go to state 84


state 52

    (51) VALUE -> openParentheses ARITEXP . closeParentheses

    closeParentheses shift and go to state 85


state 53

    (44) ARITEXP -> MULDIV . ACTION_GENERATE_QUADRUPLET_ARITEXP
    (45) ARITEXP -> MULDIV . ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> MULDIV . ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
    (64) ACTION_GENERATE_QUADRUPLET_ARITEXP -> .

    plusSign        reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    minusSign       reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    closeParentheses reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    if              reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    do              reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    call            reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    read            reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    write           reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    exit            reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    id              reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    end             reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    elif            reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    else            reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)
    semicolon       reduce using rule 64 (ACTION_GENERATE_QUADRUPLET_ARITEXP -> .)

    ACTION_GENERATE_QUADRUPLET_ARITEXP shift and go to state 86

state 54

    (47) MULDIV -> VALUE . ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> VALUE . ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> VALUE . ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (28) COMPARISON -> VALUE . COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (65) ACTION_GENERATE_QUADRUPLET_MULDIV -> .
    (30) COMP -> . doubleEqual
    (31) COMP -> . notEqual
    (32) COMP -> . biggerOrEqualThan
    (33) COMP -> . smallerOrEqualThan
    (34) COMP -> . biggerThan
    (35) COMP -> . smallerThan

    multSign        reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    divSign         reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    plusSign        reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    minusSign       reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    closeParentheses reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    doubleEqual     shift and go to state 56
    notEqual        shift and go to state 57
    biggerOrEqualThan shift and go to state 58
    smallerOrEqualThan shift and go to state 59
    biggerThan      shift and go to state 60
    smallerThan     shift and go to state 61

    ACTION_GENERATE_QUADRUPLET_MULDIV shift and go to state 87
    COMP                           shift and go to state 55

state 55

    (28) COMPARISON -> VALUE COMP . VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    VALUE                          shift and go to state 88
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 56

    (30) COMP -> doubleEqual .

    openParentheses reduce using rule 30 (COMP -> doubleEqual .)
    int             reduce using rule 30 (COMP -> doubleEqual .)
    real            reduce using rule 30 (COMP -> doubleEqual .)
    id              reduce using rule 30 (COMP -> doubleEqual .)


state 57

    (31) COMP -> notEqual .

    openParentheses reduce using rule 31 (COMP -> notEqual .)
    int             reduce using rule 31 (COMP -> notEqual .)
    real            reduce using rule 31 (COMP -> notEqual .)
    id              reduce using rule 31 (COMP -> notEqual .)


state 58

    (32) COMP -> biggerOrEqualThan .

    openParentheses reduce using rule 32 (COMP -> biggerOrEqualThan .)
    int             reduce using rule 32 (COMP -> biggerOrEqualThan .)
    real            reduce using rule 32 (COMP -> biggerOrEqualThan .)
    id              reduce using rule 32 (COMP -> biggerOrEqualThan .)


state 59

    (33) COMP -> smallerOrEqualThan .

    openParentheses reduce using rule 33 (COMP -> smallerOrEqualThan .)
    int             reduce using rule 33 (COMP -> smallerOrEqualThan .)
    real            reduce using rule 33 (COMP -> smallerOrEqualThan .)
    id              reduce using rule 33 (COMP -> smallerOrEqualThan .)


state 60

    (34) COMP -> biggerThan .

    openParentheses reduce using rule 34 (COMP -> biggerThan .)
    int             reduce using rule 34 (COMP -> biggerThan .)
    real            reduce using rule 34 (COMP -> biggerThan .)
    id              reduce using rule 34 (COMP -> biggerThan .)


state 61

    (35) COMP -> smallerThan .

    openParentheses reduce using rule 35 (COMP -> smallerThan .)
    int             reduce using rule 35 (COMP -> smallerThan .)
    real            reduce using rule 35 (COMP -> smallerThan .)
    id              reduce using rule 35 (COMP -> smallerThan .)


state 62

    (29) COMPARISON -> not LOGEXP . ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (71) ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON -> .

    and             reduce using rule 71 (ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON -> .)
    or              reduce using rule 71 (ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON -> .)
    then            reduce using rule 71 (ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON -> .)
    closeParentheses reduce using rule 71 (ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON -> .)

    ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON shift and go to state 89

state 63

    (52) VAL -> VAR ACTION_VAR_VAL .

    doubleEqual     reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    notEqual        reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    biggerOrEqualThan reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    smallerOrEqualThan reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    biggerThan      reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    smallerThan     reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    multSign        reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    divSign         reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    plusSign        reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    minusSign       reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    closeParentheses reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    if              reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    do              reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    call            reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    read            reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    write           reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    exit            reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    id              reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    end             reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    elif            reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    else            reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    and             reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    or              reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    then            reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)
    semicolon       reduce using rule 52 (VAL -> VAR ACTION_VAR_VAL .)


state 64

    (53) VAL -> int ACTION_INT_VAL .

    doubleEqual     reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    notEqual        reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    biggerOrEqualThan reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    smallerOrEqualThan reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    biggerThan      reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    smallerThan     reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    multSign        reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    divSign         reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    plusSign        reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    minusSign       reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    closeParentheses reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    if              reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    do              reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    call            reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    read            reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    write           reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    exit            reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    id              reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    end             reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    elif            reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    else            reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    and             reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    or              reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    then            reduce using rule 53 (VAL -> int ACTION_INT_VAL .)
    semicolon       reduce using rule 53 (VAL -> int ACTION_INT_VAL .)


state 65

    (54) VAL -> real ACTION_REAL_VAL .

    doubleEqual     reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    notEqual        reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    biggerOrEqualThan reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    smallerOrEqualThan reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    biggerThan      reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    smallerThan     reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    multSign        reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    divSign         reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    plusSign        reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    minusSign       reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    closeParentheses reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    if              reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    do              reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    call            reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    read            reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    write           reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    exit            reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    id              reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    end             reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    elif            reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    else            reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    and             reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    or              reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    then            reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)
    semicolon       reduce using rule 54 (VAL -> real ACTION_REAL_VAL .)


state 66

    (12) STATEMENTS -> do id equal . ARITEXP semicolon STATEMENTS end do STATEMENTS
    (44) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP
    (45) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    ARITEXP                        shift and go to state 90
    MULDIV                         shift and go to state 53
    VALUE                          shift and go to state 68
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 67

    (13) STATEMENTS -> VAR equal ARITEXP . ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (61) ACTION_GENERATE_QUADRUPLET_SET -> .

    if              reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    do              reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    call            reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    read            reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    write           reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    exit            reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    id              reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    end             reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    elif            reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)
    else            reduce using rule 61 (ACTION_GENERATE_QUADRUPLET_SET -> .)

    ACTION_GENERATE_QUADRUPLET_SET shift and go to state 91

state 68

    (47) MULDIV -> VALUE . ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> VALUE . ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> VALUE . ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (65) ACTION_GENERATE_QUADRUPLET_MULDIV -> .

    multSign        reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    divSign         reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    plusSign        reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    minusSign       reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    if              reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    do              reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    call            reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    read            reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    write           reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    exit            reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    id              reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    end             reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    elif            reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    else            reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    semicolon       reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)
    closeParentheses reduce using rule 65 (ACTION_GENERATE_QUADRUPLET_MULDIV -> .)

    ACTION_GENERATE_QUADRUPLET_MULDIV shift and go to state 87

state 69

    (51) VALUE -> openParentheses . ARITEXP closeParentheses
    (44) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP
    (45) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    ARITEXP                        shift and go to state 52
    MULDIV                         shift and go to state 53
    VALUE                          shift and go to state 68
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 70

    (14) STATEMENTS -> call id semicolon . STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 92
    VAR                            shift and go to state 15

state 71

    (15) STATEMENTS -> read READVAR semicolon . STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 93
    VAR                            shift and go to state 15

state 72

    (36) READVAR -> VAR READV .

    semicolon       reduce using rule 36 (READVAR -> VAR READV .)


state 73

    (37) READV -> coma . VAR READV
    (55) VAR -> . id ARRAY

    id              shift and go to state 11

    VAR                            shift and go to state 94

state 74

    (16) STATEMENTS -> write WRITEVAR semicolon . STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 95
    VAR                            shift and go to state 15

state 75

    (39) WRITEVAR -> VAR WRITEV .

    semicolon       reduce using rule 39 (WRITEVAR -> VAR WRITEV .)


state 76

    (41) WRITEV -> coma . VAR WRITEV
    (42) WRITEV -> coma . string WRITEV
    (55) VAR -> . id ARRAY

    string          shift and go to state 97
    id              shift and go to state 11

    VAR                            shift and go to state 96

state 77

    (40) WRITEVAR -> string WRITEV .

    semicolon       reduce using rule 40 (WRITEVAR -> string WRITEV .)


state 78

    (9) SUBROUTINES -> subroutine id STATEMENTS end . subroutine SUBROUTINES

    subroutine      shift and go to state 98


state 79

    (2) VARIABLES -> TYPE id ARRAY semicolon VARIABLES .

    subroutine      reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    if              reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    do              reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    call            reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    read            reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    write           reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    exit            reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    id              reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)
    end             reduce using rule 2 (VARIABLES -> TYPE id ARRAY semicolon VARIABLES .)


state 80

    (6) ARRAY -> openBracket int closeBracket . openBracket int closeBracket
    (7) ARRAY -> openBracket int closeBracket .

    openBracket     shift and go to state 99
    semicolon       reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    equal           reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    doubleEqual     reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    notEqual        reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    biggerOrEqualThan reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    smallerOrEqualThan reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    biggerThan      reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    smallerThan     reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    coma            reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    multSign        reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    divSign         reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    plusSign        reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    minusSign       reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    closeParentheses reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    if              reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    do              reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    call            reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    read            reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    write           reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    exit            reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    id              reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    end             reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    elif            reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    else            reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    and             reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    or              reduce using rule 7 (ARRAY -> openBracket int closeBracket .)
    then            reduce using rule 7 (ARRAY -> openBracket int closeBracket .)


state 81

    (11) STATEMENTS -> if LOGEXP then STATEMENTS . ELIF ELSE end if
    (19) ELIF -> . elif LOGEXP then STATEMENTS ELIF
    (20) ELIF -> .

    elif            shift and go to state 101
    else            reduce using rule 20 (ELIF -> .)
    end             reduce using rule 20 (ELIF -> .)

    ELIF                           shift and go to state 100

state 82

    (23) LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or . ACTION_OR_LOGEXP LOGEXP
    (66) ACTION_OR_LOGEXP -> .

    openParentheses reduce using rule 66 (ACTION_OR_LOGEXP -> .)
    not             reduce using rule 66 (ACTION_OR_LOGEXP -> .)
    int             reduce using rule 66 (ACTION_OR_LOGEXP -> .)
    real            reduce using rule 66 (ACTION_OR_LOGEXP -> .)
    id              reduce using rule 66 (ACTION_OR_LOGEXP -> .)

    ACTION_OR_LOGEXP               shift and go to state 102

state 83

    (25) ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and . ACTION_AND_ANDEXP ANDEXP
    (67) ACTION_AND_ANDEXP -> .

    openParentheses reduce using rule 67 (ACTION_AND_ANDEXP -> .)
    not             reduce using rule 67 (ACTION_AND_ANDEXP -> .)
    int             reduce using rule 67 (ACTION_AND_ANDEXP -> .)
    real            reduce using rule 67 (ACTION_AND_ANDEXP -> .)
    id              reduce using rule 67 (ACTION_AND_ANDEXP -> .)

    ACTION_AND_ANDEXP              shift and go to state 103

state 84

    (27) COMPARISON -> openParentheses LOGEXP closeParentheses .

    and             reduce using rule 27 (COMPARISON -> openParentheses LOGEXP closeParentheses .)
    or              reduce using rule 27 (COMPARISON -> openParentheses LOGEXP closeParentheses .)
    then            reduce using rule 27 (COMPARISON -> openParentheses LOGEXP closeParentheses .)
    closeParentheses reduce using rule 27 (COMPARISON -> openParentheses LOGEXP closeParentheses .)


state 85

    (51) VALUE -> openParentheses ARITEXP closeParentheses .

    doubleEqual     reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    notEqual        reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    biggerOrEqualThan reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    smallerOrEqualThan reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    biggerThan      reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    smallerThan     reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    multSign        reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    divSign         reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    plusSign        reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    minusSign       reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    closeParentheses reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    if              reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    do              reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    call            reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    read            reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    write           reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    exit            reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    id              reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    end             reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    elif            reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    else            reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    and             reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    or              reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    then            reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)
    semicolon       reduce using rule 51 (VALUE -> openParentheses ARITEXP closeParentheses .)


state 86

    (44) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .
    (45) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP . plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP . minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP

    closeParentheses reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    if              reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    do              reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    call            reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    read            reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    write           reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    exit            reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    id              reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    end             reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    elif            reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    else            reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    semicolon       reduce using rule 44 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP .)
    plusSign        shift and go to state 104
    minusSign       shift and go to state 105


state 87

    (47) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .
    (48) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV . multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV . divSign ACTION_DIVSIGN_MULDIV MULDIV

    plusSign        reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    minusSign       reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    closeParentheses reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    if              reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    do              reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    call            reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    read            reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    write           reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    exit            reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    id              reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    end             reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    elif            reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    else            reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    semicolon       reduce using rule 47 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV .)
    multSign        shift and go to state 106
    divSign         shift and go to state 107


state 88

    (28) COMPARISON -> VALUE COMP VALUE . ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (70) ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON -> .

    and             reduce using rule 70 (ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON -> .)
    or              reduce using rule 70 (ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON -> .)
    then            reduce using rule 70 (ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON -> .)
    closeParentheses reduce using rule 70 (ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON -> .)

    ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON shift and go to state 108

state 89

    (29) COMPARISON -> not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON .

    and             reduce using rule 29 (COMPARISON -> not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON .)
    or              reduce using rule 29 (COMPARISON -> not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON .)
    then            reduce using rule 29 (COMPARISON -> not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON .)
    closeParentheses reduce using rule 29 (COMPARISON -> not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON .)


state 90

    (12) STATEMENTS -> do id equal ARITEXP . semicolon STATEMENTS end do STATEMENTS

    semicolon       shift and go to state 109


state 91

    (13) STATEMENTS -> VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET . STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    VAR                            shift and go to state 15
    STATEMENTS                     shift and go to state 110

state 92

    (14) STATEMENTS -> call id semicolon STATEMENTS .

    end             reduce using rule 14 (STATEMENTS -> call id semicolon STATEMENTS .)
    elif            reduce using rule 14 (STATEMENTS -> call id semicolon STATEMENTS .)
    else            reduce using rule 14 (STATEMENTS -> call id semicolon STATEMENTS .)


state 93

    (15) STATEMENTS -> read READVAR semicolon STATEMENTS .

    end             reduce using rule 15 (STATEMENTS -> read READVAR semicolon STATEMENTS .)
    elif            reduce using rule 15 (STATEMENTS -> read READVAR semicolon STATEMENTS .)
    else            reduce using rule 15 (STATEMENTS -> read READVAR semicolon STATEMENTS .)


state 94

    (37) READV -> coma VAR . READV
    (37) READV -> . coma VAR READV
    (38) READV -> .

    coma            shift and go to state 73
    semicolon       reduce using rule 38 (READV -> .)

    READV                          shift and go to state 111

state 95

    (16) STATEMENTS -> write WRITEVAR semicolon STATEMENTS .

    end             reduce using rule 16 (STATEMENTS -> write WRITEVAR semicolon STATEMENTS .)
    elif            reduce using rule 16 (STATEMENTS -> write WRITEVAR semicolon STATEMENTS .)
    else            reduce using rule 16 (STATEMENTS -> write WRITEVAR semicolon STATEMENTS .)


state 96

    (41) WRITEV -> coma VAR . WRITEV
    (41) WRITEV -> . coma VAR WRITEV
    (42) WRITEV -> . coma string WRITEV
    (43) WRITEV -> .

    coma            shift and go to state 76
    semicolon       reduce using rule 43 (WRITEV -> .)

    WRITEV                         shift and go to state 112

state 97

    (42) WRITEV -> coma string . WRITEV
    (41) WRITEV -> . coma VAR WRITEV
    (42) WRITEV -> . coma string WRITEV
    (43) WRITEV -> .

    coma            shift and go to state 76
    semicolon       reduce using rule 43 (WRITEV -> .)

    WRITEV                         shift and go to state 113

state 98

    (9) SUBROUTINES -> subroutine id STATEMENTS end subroutine . SUBROUTINES
    (9) SUBROUTINES -> . subroutine id STATEMENTS end subroutine SUBROUTINES
    (10) SUBROUTINES -> .

    subroutine      shift and go to state 9
    if              reduce using rule 10 (SUBROUTINES -> .)
    do              reduce using rule 10 (SUBROUTINES -> .)
    call            reduce using rule 10 (SUBROUTINES -> .)
    read            reduce using rule 10 (SUBROUTINES -> .)
    write           reduce using rule 10 (SUBROUTINES -> .)
    exit            reduce using rule 10 (SUBROUTINES -> .)
    id              reduce using rule 10 (SUBROUTINES -> .)
    end             reduce using rule 10 (SUBROUTINES -> .)

    SUBROUTINES                    shift and go to state 114

state 99

    (6) ARRAY -> openBracket int closeBracket openBracket . int closeBracket

    int             shift and go to state 115


state 100

    (11) STATEMENTS -> if LOGEXP then STATEMENTS ELIF . ELSE end if
    (21) ELSE -> . else STATEMENTS
    (22) ELSE -> .

    else            shift and go to state 117
    end             reduce using rule 22 (ELSE -> .)

    ELSE                           shift and go to state 116

state 101

    (19) ELIF -> elif . LOGEXP then STATEMENTS ELIF
    (23) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP
    (24) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP
    (25) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP
    (27) COMPARISON -> . openParentheses LOGEXP closeParentheses
    (28) COMPARISON -> . VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (29) COMPARISON -> . not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 28
    not             shift and go to state 30
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    LOGEXP                         shift and go to state 118
    ANDEXP                         shift and go to state 26
    COMPARISON                     shift and go to state 27
    VALUE                          shift and go to state 29
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 102

    (23) LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP . LOGEXP
    (23) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP
    (24) LOGEXP -> . ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP
    (25) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP
    (27) COMPARISON -> . openParentheses LOGEXP closeParentheses
    (28) COMPARISON -> . VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (29) COMPARISON -> . not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 28
    not             shift and go to state 30
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    ANDEXP                         shift and go to state 26
    LOGEXP                         shift and go to state 119
    COMPARISON                     shift and go to state 27
    VALUE                          shift and go to state 29
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 103

    (25) ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP . ANDEXP
    (25) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP
    (26) ANDEXP -> . COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP
    (27) COMPARISON -> . openParentheses LOGEXP closeParentheses
    (28) COMPARISON -> . VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON
    (29) COMPARISON -> . not LOGEXP ACTION_GENERATE_QUADRUPLE_NOT_COMPARISON
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 28
    not             shift and go to state 30
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    COMPARISON                     shift and go to state 27
    ANDEXP                         shift and go to state 120
    VALUE                          shift and go to state 29
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 104

    (45) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign . ACTION_PLUSSIGN_ARITEXP ARITEXP
    (59) ACTION_PLUSSIGN_ARITEXP -> .

    openParentheses reduce using rule 59 (ACTION_PLUSSIGN_ARITEXP -> .)
    int             reduce using rule 59 (ACTION_PLUSSIGN_ARITEXP -> .)
    real            reduce using rule 59 (ACTION_PLUSSIGN_ARITEXP -> .)
    id              reduce using rule 59 (ACTION_PLUSSIGN_ARITEXP -> .)

    ACTION_PLUSSIGN_ARITEXP        shift and go to state 121

state 105

    (46) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign . ACTION_MINUSSIGN_ARITEXP ARITEXP
    (60) ACTION_MINUSSIGN_ARITEXP -> .

    openParentheses reduce using rule 60 (ACTION_MINUSSIGN_ARITEXP -> .)
    int             reduce using rule 60 (ACTION_MINUSSIGN_ARITEXP -> .)
    real            reduce using rule 60 (ACTION_MINUSSIGN_ARITEXP -> .)
    id              reduce using rule 60 (ACTION_MINUSSIGN_ARITEXP -> .)

    ACTION_MINUSSIGN_ARITEXP       shift and go to state 122

state 106

    (48) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign . ACTION_MULTSIGN_MULDIV MULDIV
    (62) ACTION_MULTSIGN_MULDIV -> .

    openParentheses reduce using rule 62 (ACTION_MULTSIGN_MULDIV -> .)
    int             reduce using rule 62 (ACTION_MULTSIGN_MULDIV -> .)
    real            reduce using rule 62 (ACTION_MULTSIGN_MULDIV -> .)
    id              reduce using rule 62 (ACTION_MULTSIGN_MULDIV -> .)

    ACTION_MULTSIGN_MULDIV         shift and go to state 123

state 107

    (49) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign . ACTION_DIVSIGN_MULDIV MULDIV
    (63) ACTION_DIVSIGN_MULDIV -> .

    openParentheses reduce using rule 63 (ACTION_DIVSIGN_MULDIV -> .)
    int             reduce using rule 63 (ACTION_DIVSIGN_MULDIV -> .)
    real            reduce using rule 63 (ACTION_DIVSIGN_MULDIV -> .)
    id              reduce using rule 63 (ACTION_DIVSIGN_MULDIV -> .)

    ACTION_DIVSIGN_MULDIV          shift and go to state 124

state 108

    (28) COMPARISON -> VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON .

    and             reduce using rule 28 (COMPARISON -> VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON .)
    or              reduce using rule 28 (COMPARISON -> VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON .)
    then            reduce using rule 28 (COMPARISON -> VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON .)
    closeParentheses reduce using rule 28 (COMPARISON -> VALUE COMP VALUE ACTION_GENERATE_QUADRUPLE_COMP_COMPARISON .)


state 109

    (12) STATEMENTS -> do id equal ARITEXP semicolon . STATEMENTS end do STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 125
    VAR                            shift and go to state 15

state 110

    (13) STATEMENTS -> VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS .

    end             reduce using rule 13 (STATEMENTS -> VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS .)
    elif            reduce using rule 13 (STATEMENTS -> VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS .)
    else            reduce using rule 13 (STATEMENTS -> VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS .)


state 111

    (37) READV -> coma VAR READV .

    semicolon       reduce using rule 37 (READV -> coma VAR READV .)


state 112

    (41) WRITEV -> coma VAR WRITEV .

    semicolon       reduce using rule 41 (WRITEV -> coma VAR WRITEV .)


state 113

    (42) WRITEV -> coma string WRITEV .

    semicolon       reduce using rule 42 (WRITEV -> coma string WRITEV .)


state 114

    (9) SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .

    if              reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)
    do              reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)
    call            reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)
    read            reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)
    write           reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)
    exit            reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)
    id              reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)
    end             reduce using rule 9 (SUBROUTINES -> subroutine id STATEMENTS end subroutine SUBROUTINES .)


state 115

    (6) ARRAY -> openBracket int closeBracket openBracket int . closeBracket

    closeBracket    shift and go to state 126


state 116

    (11) STATEMENTS -> if LOGEXP then STATEMENTS ELIF ELSE . end if

    end             shift and go to state 127


state 117

    (21) ELSE -> else . STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 128
    VAR                            shift and go to state 15

state 118

    (19) ELIF -> elif LOGEXP . then STATEMENTS ELIF

    then            shift and go to state 129


state 119

    (23) LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP .

    then            reduce using rule 23 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP .)
    closeParentheses reduce using rule 23 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP .)
    and             reduce using rule 23 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP .)
    or              reduce using rule 23 (LOGEXP -> ANDEXP ACTION_CREATE_QUADRUPLE_LOGEXP or ACTION_OR_LOGEXP LOGEXP .)


state 120

    (25) ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP .

    or              reduce using rule 25 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP .)
    then            reduce using rule 25 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP .)
    closeParentheses reduce using rule 25 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP .)
    and             reduce using rule 25 (ANDEXP -> COMPARISON ACTION_GENERATE_QUADRUPLE_ANDEXP and ACTION_AND_ANDEXP ANDEXP .)


state 121

    (45) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP . ARITEXP
    (44) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP
    (45) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    MULDIV                         shift and go to state 53
    ARITEXP                        shift and go to state 130
    VALUE                          shift and go to state 68
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 122

    (46) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP . ARITEXP
    (44) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP
    (45) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP
    (46) ARITEXP -> . MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    MULDIV                         shift and go to state 53
    ARITEXP                        shift and go to state 131
    VALUE                          shift and go to state 68
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 123

    (48) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV . MULDIV
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    VALUE                          shift and go to state 68
    MULDIV                         shift and go to state 132
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 124

    (49) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV . MULDIV
    (47) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV
    (48) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV
    (49) MULDIV -> . VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV
    (50) VALUE -> . VAL
    (51) VALUE -> . openParentheses ARITEXP closeParentheses
    (52) VAL -> . VAR ACTION_VAR_VAL
    (53) VAL -> . int ACTION_INT_VAL
    (54) VAL -> . real ACTION_REAL_VAL
    (55) VAR -> . id ARRAY

    openParentheses shift and go to state 69
    int             shift and go to state 33
    real            shift and go to state 34
    id              shift and go to state 11

    VALUE                          shift and go to state 68
    MULDIV                         shift and go to state 133
    VAL                            shift and go to state 31
    VAR                            shift and go to state 32

state 125

    (12) STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS . end do STATEMENTS

    end             shift and go to state 134


state 126

    (6) ARRAY -> openBracket int closeBracket openBracket int closeBracket .

    semicolon       reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    equal           reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    doubleEqual     reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    notEqual        reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    biggerOrEqualThan reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    smallerOrEqualThan reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    biggerThan      reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    smallerThan     reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    coma            reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    multSign        reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    divSign         reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    plusSign        reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    minusSign       reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    closeParentheses reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    if              reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    do              reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    call            reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    read            reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    write           reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    exit            reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    id              reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    end             reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    elif            reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    else            reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    and             reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    or              reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)
    then            reduce using rule 6 (ARRAY -> openBracket int closeBracket openBracket int closeBracket .)


state 127

    (11) STATEMENTS -> if LOGEXP then STATEMENTS ELIF ELSE end . if

    if              shift and go to state 135


state 128

    (21) ELSE -> else STATEMENTS .

    end             reduce using rule 21 (ELSE -> else STATEMENTS .)


state 129

    (19) ELIF -> elif LOGEXP then . STATEMENTS ELIF
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    end             reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 136
    VAR                            shift and go to state 15

state 130

    (45) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .

    closeParentheses reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    if              reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    do              reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    call            reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    read            reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    write           reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    exit            reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    id              reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    end             reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    elif            reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    else            reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)
    semicolon       reduce using rule 45 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP plusSign ACTION_PLUSSIGN_ARITEXP ARITEXP .)


state 131

    (46) ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .

    closeParentheses reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    if              reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    do              reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    call            reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    read            reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    write           reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    exit            reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    id              reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    end             reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    elif            reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    else            reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)
    semicolon       reduce using rule 46 (ARITEXP -> MULDIV ACTION_GENERATE_QUADRUPLET_ARITEXP minusSign ACTION_MINUSSIGN_ARITEXP ARITEXP .)


state 132

    (48) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .

    plusSign        reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    minusSign       reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    closeParentheses reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    if              reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    do              reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    call            reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    read            reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    write           reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    exit            reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    id              reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    end             reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    elif            reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    else            reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)
    semicolon       reduce using rule 48 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV multSign ACTION_MULTSIGN_MULDIV MULDIV .)


state 133

    (49) MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .

    plusSign        reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    minusSign       reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    closeParentheses reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    if              reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    do              reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    call            reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    read            reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    write           reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    exit            reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    id              reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    end             reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    elif            reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    else            reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)
    semicolon       reduce using rule 49 (MULDIV -> VALUE ACTION_GENERATE_QUADRUPLET_MULDIV divSign ACTION_DIVSIGN_MULDIV MULDIV .)


state 134

    (12) STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS end . do STATEMENTS

    do              shift and go to state 137


state 135

    (11) STATEMENTS -> if LOGEXP then STATEMENTS ELIF ELSE end if .

    end             reduce using rule 11 (STATEMENTS -> if LOGEXP then STATEMENTS ELIF ELSE end if .)
    elif            reduce using rule 11 (STATEMENTS -> if LOGEXP then STATEMENTS ELIF ELSE end if .)
    else            reduce using rule 11 (STATEMENTS -> if LOGEXP then STATEMENTS ELIF ELSE end if .)


state 136

    (19) ELIF -> elif LOGEXP then STATEMENTS . ELIF
    (19) ELIF -> . elif LOGEXP then STATEMENTS ELIF
    (20) ELIF -> .

    elif            shift and go to state 101
    else            reduce using rule 20 (ELIF -> .)
    end             reduce using rule 20 (ELIF -> .)

    ELIF                           shift and go to state 138

state 137

    (12) STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS end do . STATEMENTS
    (11) STATEMENTS -> . if LOGEXP then STATEMENTS ELIF ELSE end if
    (12) STATEMENTS -> . do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS
    (13) STATEMENTS -> . VAR equal ARITEXP ACTION_GENERATE_QUADRUPLET_SET STATEMENTS
    (14) STATEMENTS -> . call id semicolon STATEMENTS
    (15) STATEMENTS -> . read READVAR semicolon STATEMENTS
    (16) STATEMENTS -> . write WRITEVAR semicolon STATEMENTS
    (17) STATEMENTS -> . exit STATEMENTS
    (18) STATEMENTS -> .
    (55) VAR -> . id ARRAY

    if              shift and go to state 13
    do              shift and go to state 14
    call            shift and go to state 16
    read            shift and go to state 17
    write           shift and go to state 18
    exit            shift and go to state 19
    end             reduce using rule 18 (STATEMENTS -> .)
    elif            reduce using rule 18 (STATEMENTS -> .)
    else            reduce using rule 18 (STATEMENTS -> .)
    id              shift and go to state 11

    STATEMENTS                     shift and go to state 139
    VAR                            shift and go to state 15

state 138

    (19) ELIF -> elif LOGEXP then STATEMENTS ELIF .

    else            reduce using rule 19 (ELIF -> elif LOGEXP then STATEMENTS ELIF .)
    end             reduce using rule 19 (ELIF -> elif LOGEXP then STATEMENTS ELIF .)


state 139

    (12) STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS .

    end             reduce using rule 12 (STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS .)
    elif            reduce using rule 12 (STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS .)
    else            reduce using rule 12 (STATEMENTS -> do id equal ARITEXP semicolon STATEMENTS end do STATEMENTS .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for or in state 49 resolved as shift
WARNING: shift/reduce conflict for and in state 50 resolved as shift
